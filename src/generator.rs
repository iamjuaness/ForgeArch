use crate::templates::Template;
use anyhow::anyhow;
use anyhow::{Context, Result};
use colored::*;
use std::fs;
use std::path::Path;
use std::process::Command;
use tera::{Context as TeraContext, Tera};

/// Create a new project on disk from a `Template`.
///
/// Parameters:
/// - `name`: target path/name of the project to create (can be a relative or absolute path)
/// - `template`: the template descriptor (structure + files)
/// - `git_init`: whether to run `git init` after creating the project
/// - `readme_gen`: whether to generate README.md (default true)
/// - `force`: if true, remove existing destination before creating (allow overwrite)
pub fn create_project(
    name: &str,
    template: &Template,
    git_init: bool,
    readme_gen: bool,
    force: bool,
) -> Result<()> {
    let project_path = Path::new(name);

    // If destination exists, handle according to `force`.
    if project_path.exists() {
        if force {
            fs::remove_dir_all(project_path).context(format!(
                "Failed to remove existing project directory: {}",
                name
            ))?;
        } else {
            return Err(anyhow::anyhow!(
                "Project directory already exists: {}",
                name
            ));
        }
    }

    // Create root directory
    fs::create_dir_all(project_path)
        .context(format!("Failed to create project directory: {}", name))?;

    println!("{} Creating project structure...", "✓".green());

    // Create all folders declared in the template (IMPORTANTE: usar la estructura del template)
    if !template.structure.is_empty() {
        for folder in &template.structure {
            let folder_path = project_path.join(folder);
            fs::create_dir_all(&folder_path)
                .context(format!("Failed to create folder: {}", folder))?;
            println!("  {} {}", "→".blue(), folder);
        }
    } else {
        // Si no hay estructura definida, crear solo src por defecto
        let src_path = project_path.join("src");
        fs::create_dir_all(&src_path).context("Failed to create default src folder")?;
        println!("  {} src (default)", "→".blue());
    }

    // Build Tera instance with embedded templates.
    let mut tera = Tera::default();
    tera.add_raw_template(
        "backend/.gitignore",
        include_str!("../templates/file_templates/backend/.gitignore.tmpl"),
    )
    .map_err(|e| anyhow!("Failed to add template: {}", e))?;
    tera.add_raw_template(
        "backend/.env.example",
        include_str!("../templates/file_templates/backend/.env.example.tmpl"),
    )
    .map_err(|e| anyhow!("Failed to add template: {}", e))?;
    tera.add_raw_template(
        "frontend/.gitignore",
        include_str!("../templates/file_templates/frontend/.gitignore.tmpl"),
    )
    .map_err(|e| anyhow!("Failed to add template: {}", e))?;
    tera.add_raw_template(
        "frontend/.env.example",
        include_str!("../templates/file_templates/frontend/.env.example.tmpl"),
    )
    .map_err(|e| anyhow!("Failed to add template: {}", e))?;
    tera.add_raw_template(
        "monorepo/.gitignore",
        include_str!("../templates/file_templates/monorepo/.gitignore.tmpl"),
    )
    .map_err(|e| anyhow!("Failed to add template: {}", e))?;
    tera.add_raw_template(
        "monorepo/package.json",
        include_str!("../templates/file_templates/monorepo/package.json.tmpl"),
    )
    .map_err(|e| anyhow!("Failed to add template: {}", e))?;

    // Create files declared by the template
    if !template.files.is_empty() {
        for (file_name, file_kind) in &template.files {
            let target = project_path.join(file_name);
            if target.exists() && !force {
                println!("  {} {} (exists, skipped)", "~".yellow(), file_name);
                continue;
            }

            // Try to render a Tera template
            let template_key = format!("{}/{}", file_kind, file_name);
            let mut context = TeraContext::new();
            context.insert("project_name", name);
            let content = match tera.render(&template_key, &context) {
                Ok(s) => s,
                Err(_) => {
                    // Fallback generic content
                    format!("# File generated by ForgeArch\n# Project: {}\n", name)
                }
            };

            if let Some(parent) = target.parent() {
                fs::create_dir_all(parent).ok();
            }
            fs::write(&target, content).context(format!("Failed to write file: {}", file_name))?;
            println!("  {} {}", "●".magenta(), file_name);
        }
    }

    // Create .gitignore only if not already in template.files
    if !template.files.contains_key(".gitignore") {
        create_gitignore(project_path, force)?;
    }

    // Create README.md if requested
    if readme_gen {
        create_readme(project_path, name, template, force)?;
    }

    // Initialize git repository if requested
    if git_init {
        let status = Command::new("git")
            .arg("init")
            .current_dir(project_path)
            .status();

        match status {
            Ok(s) if s.success() => println!("  {} git initialized", "✓".green()),
            Ok(s) => println!("  {} git init exited with: {}", "!".yellow(), s),
            Err(_) => println!("  {} git not found or failed to run", "!".yellow()),
        }
    }

    println!(
        "\n{} Project '{}' created successfully!",
        "✓".green().bold(),
        name
    );
    println!("  cd {}", name);

    Ok(())
}

// File content is now provided by embedded Tera templates (see templates/file_templates/).

fn create_gitignore(path: &Path, force: bool) -> Result<()> {
    let target = path.join(".gitignore");
    if target.exists() && !force {
        // do not overwrite
        return Ok(());
    }

    let gitignore_content = "# Dependencies\nnode_modules/\ntarget/\n\n# Environment\n.env\n.env.local\n\n# Build\ndist/\nbuild/\n*.log\n";
    fs::write(target, gitignore_content).context("Failed to write .gitignore")?;
    Ok(())
}

fn create_readme(path: &Path, name: &str, template: &Template, force: bool) -> Result<()> {
    let target = path.join("README.md");
    if target.exists() && !force {
        return Ok(());
    }

    let structure_list = if template.structure.is_empty() {
        String::from("- src/ (default)\n")
    } else {
        let mut list = String::new();
        for s in &template.structure {
            list.push_str(&format!("- {}/\n", s));
        }
        list
    };

    let readme = format!(
        "# {}\n\n## Architecture: {}\n\n{}\n\n## Structure\n\n{}\n",
        name, template.name, template.description, structure_list
    );
    fs::write(target, readme).context("Failed to write README.md")?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use tempfile::tempdir;

    #[test]
    fn test_create_project_minimal() {
        let dir = tempdir().unwrap();
        let project_path = dir.path().join("myproj");
        let project_str = project_path.to_str().unwrap().to_string();

        let mut files = HashMap::new();
        files.insert(".env.example".to_string(), "backend".to_string());

        let template = Template {
            name: "Test".to_string(),
            description: "A test template".to_string(),
            structure: vec!["src".to_string(), "tests".to_string()],
            files,
        };

        // create project
        let res = create_project(&project_str, &template, false, true, false);
        assert!(res.is_ok());

        // Check folders
        assert!(project_path.join("src").exists());
        assert!(project_path.join("tests").exists());
        assert!(project_path.join(".gitignore").exists());
        assert!(project_path.join("README.md").exists());
        assert!(project_path.join(".env.example").exists());
    }

    #[cfg(unix)]
    #[test]
    fn test_permission_error() {
        use std::os::unix::fs::PermissionsExt;

        let dir = tempdir().unwrap();
        // make the directory read-only
        let meta_dir = dir.path();
        let mut perms = fs::metadata(meta_dir).unwrap().permissions();
        perms.set_mode(0o444);
        fs::set_permissions(meta_dir, perms).unwrap();

        let project_path = meta_dir.join("should_fail");
        let project_str = project_path.to_str().unwrap().to_string();

        let mut files = std::collections::HashMap::new();
        files.insert(".env.example".to_string(), "backend".to_string());

        let template = Template {
            name: "TestPerm".to_string(),
            description: "Permission test".to_string(),
            structure: vec!["src".to_string()],
            files,
        };

        let res = create_project(&project_str, &template, false, true, false);
        assert!(res.is_err());
    }
}
